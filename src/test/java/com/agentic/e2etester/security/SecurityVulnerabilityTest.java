package com.agentic.e2etester.security;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Security vulnerability and penetration tests.
 */
@SpringBootTest
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class SecurityVulnerabilityTest {
    
    @Autowired
    private SecurityManager securityManager;
    
    @Autowired
    private CredentialManager credentialManager;
    
    @Autowired
    private AuthenticationService authenticationService;
    
    @BeforeEach
    void setUp() {
        // Test setup
    }
    
    @Test
    void testBruteForceProtection() {
        // Given
        String username = "admin";
        String wrongPassword = "wrong-password";
        
        // When - Attempt brute force attack
        for (int i = 0; i < 10; i++) {
            AuthenticationResult result = securityManager.authenticate(username, wrongPassword, "127.0.0.1", "attacker-agent");
            assertFalse(result.isSuccessful());
        }
        
        // Then - Account should be locked
        assertTrue(authenticationService.isAccountLocked(username));
        
        // Even correct password should fail
        AuthenticationResult correctPasswordResult = securityManager.authenticate(username, "password", "127.0.0.1", "attacker-agent");
        assertFalse(correctPasswordResult.isSuccessful());
        assertEquals("Account is locked", correctPasswordResult.getFailureReason().orElse(""));
    }
    
    @Test
    void testConcurrentAuthenticationAttempts() throws InterruptedException {
        // Given
        ExecutorService executor = Executors.newFixedThreadPool(10);
        String username = "test-user";
        
        // When - Launch concurrent authentication attempts
        CompletableFuture<?>[] futures = new CompletableFuture[20];
        for (int i = 0; i < 20; i++) {
            final int attemptNumber = i;
            futures[i] = CompletableFuture.runAsync(() -> {
                AuthenticationResult result = securityManager.authenticate(
                    username, 
                    "wrong-password-" + attemptNumber, 
                    "127.0.0." + (attemptNumber % 10), 
                    "concurrent-attacker"
                );
                assertFalse(result.isSuccessful());
            }, executor);
        }
        
        // Wait for all attempts to complete
        CompletableFuture.allOf(futures).get(10, TimeUnit.SECONDS);
        executor.shutdown();
        
        // Then - Account should be locked due to failed attempts
        assertTrue(authenticationService.isAccountLocked(username));
    }
    
    @Test
    void testSqlInjectionInCredentialName() {
        // Given - Attempt SQL injection in credential name
        String maliciousName = "'; DROP TABLE credentials; --";
        
        // When
        Credential credential = credentialManager.storeCredential(
            maliciousName, 
            CredentialType.SECRET, 
            "test-value", 
            null
        );
        
        // Then - Should store safely without executing SQL injection
        assertNotNull(credential);
        assertEquals(maliciousName, credential.getName());
        
        // Verify credential can be retrieved
        var retrieved = credentialManager.getCredential(maliciousName);
        assertTrue(retrieved.isPresent());
        assertEquals(maliciousName, retrieved.get().getName());
    }
    
    @Test
    void testXssInAuditData() {
        // Given - Attempt XSS in audit data
        String xssPayload = "<script>alert('xss')</script>";
        Map<String, Object> maliciousData = Map.of(
            "userInput", xssPayload,
            "description", "<img src=x onerror=alert('xss')>"
        );
        
        // When - Record audit event with malicious data
        AuthenticationResult authResult = securityManager.authenticate("admin", "password", "127.0.0.1", "test-agent");
        SecurityContext context = authResult.getSecurityContext().orElseThrow();
        
        securityManager.recordSecurityEvent(
            context,
            AuditEventType.TEST_EXECUTION,
            "test-resource",
            "TEST_ACTION",
            AuditResult.SUCCESS,
            maliciousData
        );
        
        // Then - Data should be stored safely (implementation should sanitize)
        // This test verifies that the system doesn't crash and handles malicious input
        assertNotNull(context);
    }
    
    @Test
    void testCredentialEncryptionSecurity() {
        // Given
        String sensitiveValue = "super-secret-password-123!@#";
        
        // When
        Credential credential = credentialManager.storeCredential(
            "encryption-test",
            CredentialType.USERNAME_PASSWORD,
            sensitiveValue,
            null
        );
        
        // Then - Encrypted value should not contain the original value
        assertNotEquals(sensitiveValue, credential.getEncryptedValue());
        assertFalse(credential.getEncryptedValue().contains(sensitiveValue));
        assertFalse(credential.getEncryptedValue().contains("password"));
        assertFalse(credential.getEncryptedValue().contains("123"));
        
        // But decrypted value should match
        var decryptedValue = credentialManager.getCredentialValue(credential.getCredentialId());
        assertTrue(decryptedValue.isPresent());
        assertEquals(sensitiveValue, decryptedValue.get());
    }
    
    @Test
    void testSessionHijackingProtection() {
        // Given - Legitimate authentication
        AuthenticationResult authResult = securityManager.authenticate("admin", "password", "127.0.0.1", "legitimate-agent");
        String sessionId = authResult.getSessionId().orElseThrow();
        
        // When - Try to use session from different IP (simulating session hijacking)
        var context1 = securityManager.getSecurityContext(sessionId);
        assertTrue(context1.isPresent());
        assertEquals("127.0.0.1", context1.get().getClientIpAddress());
        
        // Then - Session should still be valid (basic implementation doesn't check IP changes)
        // In a production system, you might want to invalidate sessions on IP changes
        assertTrue(context1.isPresent());
    }
    
    @Test
    void testInvalidSessionTokens() {
        // Given - Various invalid session tokens
        String[] invalidTokens = {
            null,
            "",
            "invalid-session-id",
            "../../etc/passwd",
            "<script>alert('xss')</script>",
            "'; DROP TABLE sessions; --",
            "very-long-session-id-that-might-cause-buffer-overflow-" + "x".repeat(1000)
        };
        
        // When/Then - All should return empty context
        for (String invalidToken : invalidTokens) {
            var context = securityManager.getSecurityContext(invalidToken);
            assertTrue(context.isEmpty(), "Invalid token should not return context: " + invalidToken);
        }
    }
    
    @Test
    void testCredentialAccessWithoutAuthorization() {
        // Given - Create credential as admin
        AuthenticationResult adminAuth = securityManager.authenticate("admin", "password", "127.0.0.1", "admin-agent");
        String adminSessionId = adminAuth.getSessionId().orElseThrow();
        
        Credential credential = credentialManager.storeCredential("sensitive-cred", CredentialType.SECRET, "top-secret", null);
        
        // Authenticate as test executor (limited permissions)
        AuthenticationResult executorAuth = securityManager.authenticate("test-executor", "password", "127.0.0.1", "executor-agent");
        String executorSessionId = executorAuth.getSessionId().orElseThrow();
        
        // When - Try to delete credential as test executor (should fail)
        AuthorizationResult deleteResult = securityManager.authorizeCredentialAccess(
            executorSessionId, 
            credential.getCredentialId(), 
            "DELETE"
        );
        
        // Then
        assertFalse(deleteResult.isAuthorized());
        assertTrue(deleteResult.getRequiredRole().isPresent());
        assertEquals("ADMIN", deleteResult.getRequiredRole().get());
        
        // When - Try to write credential as test executor (should fail)
        AuthorizationResult writeResult = securityManager.authorizeCredentialAccess(
            executorSessionId, 
            credential.getCredentialId(), 
            "WRITE"
        );
        
        // Then
        assertFalse(writeResult.isAuthorized());
        
        // When - Try to read credential as test executor (should succeed)
        AuthorizationResult readResult = securityManager.authorizeCredentialAccess(
            executorSessionId, 
            credential.getCredentialId(), 
            "READ"
        );
        
        // Then
        assertTrue(readResult.isAuthorized());
    }
    
    @Test
    void testProductionEnvironmentProtection() {
        // Given - Authenticate as test executor
        AuthenticationResult executorAuth = securityManager.authenticate("test-executor", "password", "127.0.0.1", "executor-agent");
        String executorSessionId = executorAuth.getSessionId().orElseThrow();
        
        // When - Try to run test in production environment
        AuthorizationResult prodResult = securityManager.authorizeTestExecution(
            executorSessionId, 
            "critical-test", 
            "production"
        );
        
        // Then - Should be denied
        assertFalse(prodResult.isAuthorized());
        assertTrue(prodResult.getRequiredRole().isPresent());
        assertEquals("ADMIN or CICD_SYSTEM", prodResult.getRequiredRole().get());
        
        // When - Try to run test in development environment
        AuthorizationResult devResult = securityManager.authorizeTestExecution(
            executorSessionId, 
            "test-123", 
            "development"
        );
        
        // Then - Should be allowed
        assertTrue(devResult.isAuthorized());
    }
    
    @Test
    void testApiKeySecurityValidation() {
        // Given - Various potentially malicious API keys
        String[] maliciousApiKeys = {
            "'; DROP TABLE users; --",
            "<script>alert('xss')</script>",
            "../../../etc/passwd",
            "admin' OR '1'='1",
            null,
            "",
            "x".repeat(10000) // Very long key
        };
        
        // When/Then - All should fail authentication safely
        for (String maliciousKey : maliciousApiKeys) {
            AuthenticationResult result = securityManager.authenticateWithApiKey(
                maliciousKey, 
                "127.0.0.1", 
                "malicious-agent"
            );
            assertFalse(result.isSuccessful(), "Malicious API key should not authenticate: " + maliciousKey);
        }
    }
    
    @Test
    void testMemoryLeakPrevention() {
        // Given - Create many sessions to test memory management
        for (int i = 0; i < 100; i++) {
            AuthenticationResult result = securityManager.authenticate(
                "admin", 
                "password", 
                "127.0.0." + (i % 255), 
                "load-test-agent-" + i
            );
            
            if (result.isSuccessful()) {
                String sessionId = result.getSessionId().orElseThrow();
                
                // Use session briefly then invalidate
                securityManager.getSecurityContext(sessionId);
                securityManager.invalidateSession(sessionId);
            }
        }
        
        // Then - System should handle this without memory issues
        // This is more of a load test to ensure no obvious memory leaks
        assertTrue(true); // If we get here without OutOfMemoryError, test passes
    }
}